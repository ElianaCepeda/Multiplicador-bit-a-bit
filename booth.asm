	; Evalúa sí Acc es cero
	jz load_a
ind_1:
	; Se carga la variable Q a registro A
	mov ACC, Q
    mov DPTR, ACC
	mov ACC, [DPTR]
	mov A, ACC
	call fn_1 

	hlt ; Se detiene la ejecucion


load_a:
	; Se carga Variable A a Acc
	mov ACC, variableA
    mov DPTR, ACC
	mov ACC, [DPTR]
	jz ind_1
	hlt

fn_1:
	; Se carga Variable count a Acc
	mov ACC, count
    mov DPTR, ACC
	mov ACC, [DPTR]
	ret ;retorna al punto donde se ejecutó CALL CTE

; Multiplicador

INIT:
load_Q: MOV ACC, CTE 
Q #Cargar Q que será el multiplicando
MOV DPTR, ACC
MOV ACC, [DPTR]
MOV A, ACC #Mover lo que está en ACC (Q) al registro A
fnd_LSB: MOV ACC, CTE
0x01 #Cargar 1 para hallar el LSB
AND ACC, A #AND ENTRE A Y ACC para obtener 1 o 0 dependiendo del 
caso
MOV A, ACC #EL LSB SE MUEVE A REGISTRO A
Load_lSB: MOV ACC, CTE
LSB #se carga la direccion de LSB
MOV DPTR, ACC
MOV ACC, [DPTR] #Carga el [LSB] en ACC
#verificar si es 10, 01, 11, 00
Loop_0_1: MOV A, ACC #cargar LSB en A
MOV ACC, CTE
0x01 #cargar 1
INV ACC #COMPLEMENTO A 1 DE 1
MOV A, ACC #COMPLENTO 1 DE 1 EN REGISTRO DE A
MOV ACC, CTE
0x01
ADD ACC, A #COMPLEMENTO 2 DE 1
MOV A, ACC # COMPLEMENTO A 2 EN A REGISTER
MOV ACC, CTE
LSB #se carga la direccion de LSB
MOV DPTR, ACC
MOV ACC, [DPTR] #Carga el [LSb] en ACC
ADD ACC, A #EN ACC LSB-1 
JZ CTE
Q1 #SI ACC ES 1
JMP CTE
Q0 #SI ACC ES 0
//verificar si es 10
Q1: MOV ACC, CTE
0x01 #cargar 1
INV ACC #COMPLEMENTO A 1 DE 1
MOV A, ACC #COMPLENTO 1 DE 1 EN REGISTRO DE A
MOV ACC, CTE
0x01
ADD ACC, A #COMPLEMENTO 2 DE 1
MOV A, ACC # COMPLEMENTO A 2 EN A REGISTER
MOV ACC, CTE
0x01
ADD ACC, A #COMPLEMENTO 2 DE 1
MOV A, ACC # COMPLEMENTO A 2 EN A REGISTER
ADD ACC, A
MOV ACC, CTE
QLSB #se carga la direccion de LSB
MOV DPTR, ACC
MOV ACC, [DPTR] #Carga el [LSB] en ACC
MOV A, ACC
ADD ACC, A #ACC QLSB - 1
JZ CTE #VERIFICA SI ACC ES 0
ARITH_SHIFT
JMP CTE #VERIFIQUE SI ES 1
UNOCERO
//VERIFICAR SI ES 01
Load_Q: MOV ACC, CTE 
Q #CARGAMOS Q QUIEN SERA EL MULTIPLICANDO
MOV DPTR, ACC
MOV ACC,[DPTR]
MOV A, ACC #Q QUIEN ESTABA EN EL ACUMULADOR SE MUEVE A 
REGISTRO A
fnd_LSB: MOV ACC, CTE
0x01 #CARGAR 1 PARA HALLAR EL LSB
AND ACC, A #AND ENTRE A Y ACC para obtener 1 o 0 dependiendo del 
caso
MOV A, ACC #EL LSB SE MUEVE A REGISTRO A
Load_lSB: MOV ACC, CTE
LSB #se carga la direccion de LSB
MOV DPTR, ACC
MOV ACC, [DPTR] #Carga el [LSB] en ACC
#verificar si es 10, 01, 11, 00
Loop_0_1: MOV A, ACC #cargar LSB en A
MOV ACC, CTE
0x01 #cargar 1
INV ACC #COMPLEMENTO A 1 DE 1
MOV A, ACC #COMPLENTO 1 DE 1 EN REGISTRO DE A
MOV ACC, CTE
0x01
ADD ACC, A #COMPLEMENTO 2 DE 1
MOV A, ACC # COMPLEMENTO A 2 EN A REGISTER
MOV ACC, CTE
LSB #se carga la direccion de LSB
MOV DPTR, ACC
MOV ACC, [DPTR] #Carga el [LSB] en ACC
ADD ACC, A #EN ACC LSB-1 
JZ CTE
Q1 #SI ACC ES 1
JMP CTE
Q0 #SI ACC ES 0
//verificar si es 10
Q1: MOV ACC, CTE
0x01 #cargar 1
INV ACC #COMPLEMENTO A 1 DE 1
MOV A, ACC #COMPLENTO 1 DE 1 EN REGISTRO DE A
MOV ACC, CTE
0x01
ADD ACC, A #COMPLEMENTO 2 DE 1
MOV A, ACC # COMPLEMENTO A 2 EN A REGISTER
MOV ACC, CTE
0x01
ADD ACC, A #COMPLEMENTO 2 DE 1
MOV A, ACC # COMPLEMENTO A 2 EN A REGISTER
ADD ACC, A
MOV ACC, CTE
Q1 #se carga la direccion de LSB
MOV DPTR, ACC
MOV ACC, [DPTR] #Carga el [Q1] en ACC
MOV A, ACC
MOV ACC, CTE 
VQ1 #CARGAMOS Q-1 
MOV DPTR, ACC
ADD ACC, A #ACC Q1 - 1
MOV ACC,[DPTR]
JZ CTE #VERIFICA SI ACC ES 0
ARITH_SHIFT
JMP CTE #VERIFIQUE SI ES 1
UNOCERO
//VERIFICAR SI ES 01
Q0: MOV ACC, CTE
Q0
MOV DPTR, ACC 
MOV ACC, [DTPR] #CARGAR [Q0]
Inv ACC #COMPLEMTO A UNO DE Q0
MOV A, ACC
MOV ACC, CT0X01 #CARGAR EL UNO
ADD ACC, A #ACC -Q0+1 PARA COMPLENTO A DOS
MOV ACC, CTE 
VQ1 #CARGAMOS Q-1 
MOV DPTR, ACC
ADD ACC, A #ACC Q1 - 1
MOV ACC,[DPTR]
JZ CTE
CEROUNO #SI ES 0 HAGA LAS OPERCACIONES 
CORRESPONDIENTES DE 01
JMP CTE
ARITH_SHIFT #SI NO ES 0 SALTE Y EJECUTE
UN0CERO: MOV ACC, CTE
M
MOV DPTR, ACC 
MOV ACC, [DPTR] #OBTENEMOS EL VALOR DEL DPTR [M]
INV ACc #comoplement a uno de M
MOV A, ACC #COMPLENTO A UNO EN REGISTRO A
MOV ACC, CTE
0x01 #LOAD 1
ADD ACC, A #COMPLEMENTO A DOS EN ACC
MOV A, ACC #EN A COMPLEMENTO A DOS
MOV ACC, CTE
X
MOV DPTR, ACC #LOAD X
ADD ACC, A #X-M EN ACC
MOV [DPTR], ACC #EL RESULTADO DE LA RESTA EN EL VALOR DE 
X
JMP CTE 
ARITH_SHIFT
CEROUNO:
load M: MOV ACC, CTE 
M
MOV DPTR, ACC
MOV ACC, [DPTR]
MOV A, ACC
load X: MOV ACC, CTE 
X
MOV DPTR, ACC
MOV ACC, [DPTR]
ADD ACC, A
MOV [DPTR], ACC #X=X+M
JMP CTE 
ARITH_SHIFT
ARITH_SHIFT:
load X: MOV ACC, CTE 
X
MOV DPTR, ACC
MOV ACC, [DPTR]
SAR ACC, CTE
1
MOV [DPTR], ACC #la variable X se dezplazó 1 a la derecha y se 
volvio a guardar en X
load VQ: MOV ACC, CTE 
VQ
MOV DPTR, ACC
MOV ACC, [DPTR]
SAR ACC, CTE
1
MOV [DPTR], ACC #la variable VQ se dezplazó 1 a la derecha y se 
volvio a guardar en VQ
load VQ1: MOV ACC, CTE 
VQ1
MOV DPTR, ACC
MOV ACC, [DPTR]
SAR ACC, CTE
1
MOV [DPTR], ACC #la varieble VQ1 se dezplazó 1 a la derecha y se 
volvio a guardar en VQ1
load CONT: MOV ACC, CTE 
CONT
MOV DPTR, ACC
MOV ACC, [DPTR]
MOV A, ACC
MOV ACC, CTE
0x1111 #complemtento a 2 de 1
ADD ACC, A
MOV [DPTR], ACC; A contador se le restó 1
JZ CTE
HALT
JMP CTE
INI
